[request_definition]
# リクエスト（アクセス要求）の定義。
# sub: subject (アクセス主体。ここではJWTに含まれるロール文字列を想定) 
# obj: object (保護対象のリソース名。例: users, groups, members, roles など)
# act: action (操作種別。read / write の2値を基本とし、HTTPメソッドをマッピング)
#   - GET    -> read
#   - HEAD   -> read
#   - OPTIONS-> read
#   - POST   -> write
#   - PUT    -> write
#   - PATCH  -> write
#   - DELETE -> write
r = sub, obj, act

[policy_definition]
# ポリシー（許可ルール）の定義。
# p, sub, obj, act の形式で1行が1ルール。
# 例: p, admin, users, write  -> admin ロールは users リソースに対し write(=POST/PUT/DELETE等)を許可。
p = sub, obj, act

[role_definition]
# RBAC 階層定義 (ロール継承)。
# g = user_role, parent_role の形式で記述可能。
# 例: policy.csv に g, operator, user を追加すると operator は user の権限を継承できる。
# 現状は明示的な継承を使っていないが、将来的な拡張のために有効化。
g = _, _

[policy_effect]
# エフェクト（複数マッチ時の集約）定義。
# some(where (p.eft == allow)) は「1つでも allow ルールにマッチすれば許可」を意味する。
# deny ルールを併用する場合はここをカスタマイズ（例えば priority モデル）可能。
e = some(where (p.eft == allow))

[matchers]
# マッチャー（リクエストとポリシーの突き合わせ）式。
# r.sub == p.sub: リクエスト主体のロールがポリシーのロールと一致
# r.obj == p.obj: リソース名が一致
# r.act == p.act: アクション(read/write) が一致
# すべて一致した場合にそのポリシーが適用される。
# 将来、リソースパスをパターン( keyMatch )で柔軟化したい場合は以下のように変更可能:
#   m = r.sub == p.sub && keyMatch(r.obj, p.obj) && r.act == p.act
m = r.sub == p.sub && r.obj == p.obj && r.act == p.act
